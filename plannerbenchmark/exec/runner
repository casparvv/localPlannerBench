#! /usr/bin/env python3

import time
import argparse
import subprocess
import datetime
import time
import os
import sys
import csv
import warnings
import numpy as np
import signal

plannerbench_path = "/home/celepar/Develop/localPlannerBench"
sys.path.insert(0, plannerbench_path)

from plannerbenchmark.generic.experiment import Experiment, ExperimentInfeasible
from plannerbenchmark.generic.logger import Logger

from plannerbenchmark.generic.planner  import PlannerRegistry
from plannerbenchmark.planner import *


def blockPrint():
    sys.stdout = open(os.devnull, 'w')
    warnings.filterwarnings('ignore')


def enablePrint():
    sys.stdout = sys.__stdout__


class Runner(object):
    def __init__(self):
        self.initializeArgumentParser()
        signal.signal(signal.SIGINT, self.handleStop)
        self._aborted = False

    def handleStop(self, signum, frame):
        print("\n Stopping runner...")
        self.stopEnvironment()
        self._aborted = True

    def initializeArgumentParser(self):
        self._parser = argparse.ArgumentParser("Run motion planning experiment")
        self._parser.add_argument(
            "--caseSetup", "-case", type=str, help="Experiment setup file", required=True
        )
        self._parser.add_argument(
            "--planners", "-p", type=str, nargs="+", help="List of planner setup files", required=True
        )
        self._parser.add_argument(
            "--res-folder",
            "-res",
            type=str,
            default='results',
            help="Results folder",
        )
        self._parser.add_argument(
            "--numberRuns", "-n", type=int, default=1, help="Number of runs of the experiment"
        )
        self._parser.add_argument(
            "--show-rays", "-sr", type=bool, default=False, help="Show LiDAR ray visualization by setting to True"
        )
        self._parser.add_argument("--ros", dest="ros", action="store_true")
        self._parser.add_argument("--no-save", dest="save", action="store_false")
        self._parser.add_argument("--random-goal", dest="random_goal", action="store_true")
        self._parser.add_argument("--random-obst", dest="random_obst", action="store_true")
        self._parser.add_argument("--random-init", dest="random_init", action="store_true")
        self._parser.add_argument("--no-verbose", dest="verbose", action="store_false")
        self._parser.add_argument("--render", dest="render", action="store_true")
        self._parser.add_argument("--compare", dest="compare", action="store_true")
        self._parser.set_defaults(save=True)
        self._parser.set_defaults(ros=False)
        self._parser.set_defaults(random_goal=False)
        self._parser.set_defaults(random_obst=False)
        self._parser.set_defaults(random_init=False)
        self._parser.set_defaults(verbose=True)
        self._parser.set_defaults(render=False)
        self._parser.set_defaults(compare=False)
 
    def parseArguments(self):
        args = self._parser.parse_args()
        self._render = args.render
        self._save = args.save
        self._random_obst = args.random_obst
        self._random_init = args.random_init
        self._random_goal = args.random_goal
        self._numberRuns = args.numberRuns
        self._verbose = args.verbose
        self._render = args.render
        self._res_folder = os.getcwd() + '/' + args.res_folder
        self._planners = []
        self._experiment = Experiment(args.caseSetup)
        self._ros = args.ros
        self._compare = args.compare
        self._show_rays = args.show_rays
        if self._compare:
            self._compareTimeStamp = args.caseSetup[-24:-9]
        if self._ros:
            self.startRosConverterNode()
        else:
            self._env = self._experiment.env(render=self._render)
        for planner_file in args.planners:
            planner = PlannerRegistry.create_planner(self._experiment, planner_file)
            self._planners.append(planner)

    def startRosConverterNode(self):
        from plannerbenchmark.ros.ros_converter_node import ActionConverterNode
        dt = self._experiment.dt()
        rate_int = int(1/dt)
        self._rosConverter = ActionConverterNode(dt, rate_int, self._experiment.robotType())

    def setPlanner(self):
        composition_time = {}
        for planner in self._planners:
            start_composition = time.perf_counter()
            planner.reset()
            planner.setJointLimits(self._experiment.limits())
            planner.setSelfCollisionAvoidance(self._experiment.rBody())
            planner.setObstacles(self._experiment.obstacles(), self._experiment.rBody())
            planner.setGoal(self._experiment.goal())
            planner.concretize()
            end_composition = time.perf_counter()
            try:
                planner_name = planner._config.number_lidar_rays
            except:
                planner_name = planner._config.name
            composition_time[planner_name] = np.round(end_composition-start_composition, decimals=2)
        return composition_time

    def applyAction(self, action, t_exp):
        if self._ros:
            ob, t = self._rosConverter.publishAction(action)
            self._rosConverter.setGoal(self._experiment.primeGoal(), t=t_exp)
            for i, obst in enumerate(self._experiment.obstacles()):
                self._rosConverter.setObstacle(obst, i, t=t_exp)
        else:
            ob, _, _, _ = self._env.step(action)
            t = t_exp + self._experiment.dt()
            show_state = False
            if show_state is True:
                print(f"ob: {ob}")
                print(f"action: {action}")
                print(f"t: {t}")
        return ob, t

    def reset(self, q0, q0dot):
        if self._ros:
            ob, t0 = self._rosConverter.ob()
            self._rosConverter.setGoal(self._experiment.primeGoal())
            for i, obst in enumerate(self._experiment.obstacles()):
                self._rosConverter.setObstacle(obst, i)
        else:
            ob = self._env.reset(pos=q0, vel=q0dot)
            t0 = 0.0
        return ob, t0

    def stopEnvironment(self):
        """
        if self._ros:
            res = subprocess.run(['/bin/zsh', '-i', '-c', 'stopMotion'], stdout=subprocess.PIPE)
            print(res)
        """
        return

    def run(self):
        print("start run")
        completedRuns = 0
        print("Composing the planner(s)")
        composition_time = self.setPlanner()
        print(f"Planner(s) composed in {composition_time} sec")
        while completedRuns < self._numberRuns:
            self._experiment.shuffle(self._random_obst, self._random_init, self._random_goal)
            try:
                self._experiment.checkFeasibility(checkGoalReachible=False)
                completedRuns += 1
            except ExperimentInfeasible as e:
                print("Case not feasible %s" % str(e))
                continue
            # q0, q0dot = self._experiment.initState()
            timeStamp = "{:%Y%m%d_%H%M%S}".format(datetime.datetime.now())
            if self._compare:
                timeStamp = self._compareTimeStamp
            for planner in self._planners:
                q0, q0dot = self._experiment.initState()
                ob, t0 = self.reset(q0, q0dot)
                
                try:
                    # Sets the lidar data to 100.0 for the first step.
                    #  Otherwise, it is filled with 0s after one run or badly shaped after using
                    #  two sensor fabric planner in a row (using the old shape in the first step).
                    ob['robot_0']['LidarSensor'] = np.full([planner._config.number_lidar_rays*2,], 100.0)
                except AttributeError:
                    print("No lidar sensor available to set default values to 100.0")
                
                if not self._ros:
                    try:
                        self._experiment.addScene(self._env, planner._config.number_lidar_rays)
                        print(f"adding experiment {planner._config.number_lidar_rays}")
                    except AttributeError:
                        print("No lidar sensor added to the environment.")
                        self._experiment.addScene(self._env)

                if len(self._planners) > 1:
                    if planner._config.name == "fabric":
                        logger = Logger(self._res_folder, "0" + "_" + timeStamp)
                    else:
                        logger = Logger(self._res_folder, str(planner._config.number_lidar_rays) + "_" + timeStamp)
                else:
                    logger = Logger(self._res_folder, timeStamp)
                logger.setSetups(self._experiment, planner)
                t = 0.0
                for i in range(self._experiment.T()):
                    if self._aborted:
                        break
                    if i % 1000 == 0:
                        print("Timestep : %d" %i)
                    q = ob['robot_0']['joint_state']['position']
                    qdot = ob['robot_0']["joint_state"]["velocity"]
                    if self._experiment.dynamic():
                        envEval = self._experiment.evaluate(t)
                        if not planner.config.dynamic:
                            envEval[1] = np.zeros(envEval[1].size)
                            envEval[2] = np.zeros(envEval[2].size)
                        observation = [q, qdot] + envEval
                    else:
                        observation = [q, qdot]
                    if self._experiment.robotType() in ['groundRobot', 'boxer', 'albert']:
                        qudot = np.concatenate((ob['vel'], ob['xdot'][3:]))
                        observation += [qudot]
                    try:
                        sensor_data = ob['robot_0']['LidarSensor']
                        #if self._show_rays:
                            #if i == 0:
                            #    # Set body_ids_old to None for the first time creating ray visualizations.
                            #    body_ids_old = None
                            #show_lidar_mode = "spheres" # "rays_spheres" for full visualization or "spheres" for sphere visualizations only (faster).
                            #if show_lidar_mode == "rays_spheres": show_lidar_step = 30
                            #else: show_lidar_step = 1
                            #if i in range(1, self._experiment.T(), show_lidar_step):
                            #    body_ids_old = self._experiment.showLidar(self._env, sensor_data, q, body_ids_old, planner._config.number_lidar_rays, show_lidar_mode)
                        observation += [sensor_data]
                    except KeyError as key_error:
                        observation += [0]
                    
                    t_before = time.perf_counter()
                    observation += [np.around(t, 4)]
                    if planner._config.name == "fabric":
                        observation += [self._experiment.evaluateObstacles(t)]
                    action = planner.computeAction(*observation)
                    if np.isnan(action).any():
                        print(f"Action contains NaN values, using zero velocity instead.")
                        action = np.zeros_like(action)
                    solving_time = time.perf_counter() - t_before
                    primeGoal = [self._experiment.evaluatePrimeGoal(t)]
                    obsts = self._experiment.evaluateObstacles(t)
                    obsts_cleaned = [obsts[i:i+3] for i in range(0, len(obsts), 3)]
                    logger.addResultPoint(t, q, qdot, action, solving_time, primeGoal, obsts_cleaned)
                    ob, t_new = self.applyAction(action, t)
                    t = t_new - t0
                if self._save:
                    logger.save()
            print("Completed %d runs" % completedRuns)
            with open(str(self._res_folder) + '/' + 'composition_time.csv', 'w') as csv_file:
                writer = csv.writer(csv_file)
                for key, value in composition_time.items():
                    writer.writerow([key, value])
            self.stopEnvironment()

def newmain():
    myRunner = Runner()
    myRunner.parseArguments()
    myRunner.run()


if __name__ == "__main__":
    newmain()
