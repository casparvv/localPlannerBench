#! /usr/bin/python3

import numpy as np
import csv
import sys
import yaml
import pprint

from metrics import (
    DistanceToPointMetric,
    MinimumDistanceToPointMetric,
    TimeToReachGoalMetric,
    ClearanceMetric,
    SelfClearanceMetric,
    SolverTimesMetric,
    PathLengthMetric,
    SuccessMetric
)


def csvToRawData(fileName):
    with open(fileName) as csvfile:
        reader = csv.reader(csvfile, delimiter=",")
        return list(reader)


def listStr2FloatArray(strList):
    return np.array([float(entry) for entry in strList])


class PostProcessor(object):
    def __init__(self, pathToExp):
        self._pathToExp = pathToExp
        self._resFile = pathToExp + "/res.csv"
        self._params = {}
        self._metrices = []

    def importData(self):
        self.convertDataPoints(csvToRawData(self._resFile))

    def importConfig(self):
        setupFile = self._pathToExp + "/exp.yaml"
        with open(setupFile, 'r') as stream:
            self._params = yaml.safe_load(stream)
        self._params['goal'] = listStr2FloatArray(self._params['goal'])
        floatObstacles = []
        for obst in self._params['obstacles']:
            floatDict = {}
            floatDict['r'] = float(obst['r'])
            floatDict['x'] = listStr2FloatArray(obst['x'])
            floatObstacles.append(floatDict)
        self._params['obstacles'] = floatObstacles
        plannerFile = self._pathToExp + "/planner.yaml"
        with open(plannerFile, 'r') as stream:
            self._plannerparams = yaml.safe_load(stream)
        if not ('interval' in self._plannerparams.keys()):
            self._plannerparams['interval'] = 1

    def processHeader(self, header):
        headerDict = {}
        for i, entry in enumerate(header):
            headerDict[entry] = i
        return headerDict

    def convertDataPoints(self, rawdata):
        nbPoints = len(rawdata) - 1
        self._data = {}
        headerDict = self.processHeader(rawdata[0])
        for name in headerDict.keys():
            self._data[name] = np.array(
                [float(rawdata[i][headerDict[name]]) for i in range(1, nbPoints)]
            )

    def evaluateMetric(self, metric):
        return metric.computeMetric(self._data)

    def addMetric(self, metric):
        self._metrices.append(metric)

    def evaluate(self):
        self._evaluations = {}
        for metric in self._metrices:
            res = metric.computeMetric(self._data)
            self._evaluations[metric._name] = res

    def getEval(self):
        return self._evaluations

    def evaluateSuccess(self):
        if 'selfClearance' in self._evaluations.keys():
            minClearance = min(self._evaluations['clearance']['minDist'], self._evaluations['selfClearance']['minDist'])
        else:
            minClearance = self._evaluations['clearance']['minDist']
        reachingFlag = self._evaluations['time2Goal'][0]
        successMetric = SuccessMetric(
            "success",
            [],
            {'minClearance': minClearance, 'reachingFlag': reachingFlag},
        )
        self._evaluations['success'] = self.evaluateMetric(successMetric)

    def writeEval2ResultFolder(self):
        postProcessFile =  self._pathToExp + "/postProcess.yaml"
        with open(postProcessFile, 'w') as file:
            yaml.dump(self._evaluations, file)


def postProcessPointMass(pathToData):
    pp = PostProcessor(pathToData)
    pp.importData()
    pp.importConfig()
    timeToReachGoalMetric = TimeToReachGoalMetric(
        "time2Goal",
        ["q0", "q1", "t"],
        {"goal": pp._params["goal"], "des_distance": 0.001},
    )
    clearanceMetric = ClearanceMetric(
        "clearance",
        ["q0", "q1"],
        {"obstacles": pp._params["obstacles"], "n": 0, "m": 2, "r_body" : 0.0},
    )
    solverTimesMetric = SolverTimesMetric(
        "solvertime",
        ["t_planning"],
        {"interval": pp._plannerparams['interval']}
    )
    pathLengthMetric = PathLengthMetric(
        "pathLength",
        ["q0", "q1"],
        {}
    )
    pp.addMetric(clearanceMetric)
    pp.addMetric(timeToReachGoalMetric)
    pp.addMetric(solverTimesMetric)
    pp.addMetric(pathLengthMetric)
    pp.evaluate()
    pp.evaluateSuccess()
    pp.writeEval2ResultFolder()
    pprint.pprint(pp.getEval())
    """
    print("success : ", pp.evaluateMetric(successMetric))
    """

def postProcessPlanarArm(pathToData):
    n = 5
    m = 2
    jointNames = ["q" + str(i) for i in range(n)]
    fksNames = []
    for i in range(n+1):
        fksNames.append("fk" + str(i) + "_x")
        fksNames.append("fk" + str(i) + "_y")
    fkNames = ["fk" + str(n) + "_x", "fk" + str(n) + "_y"]
    pp = PostProcessor(pathToData)
    pp.importData()
    pp.importConfig()
    timeToReachGoalMetric = TimeToReachGoalMetric(
        "time2Goal",
        fkNames + ["t"],
        {"goal": pp._params["goal"], "des_distance": 0.001},
    )
    clearanceMetric = ClearanceMetric(
        "clearance",
        fksNames,
        {"obstacles": pp._params["obstacles"], "m": m, "n": n, "r_body": 0.51},
    )
    selfClearanceMetric = SelfClearanceMetric(
        "selfClearance",
        fksNames,
        {"m": m, "n": n, "r_body": 0.51},
    )
    solverTimesMetric = SolverTimesMetric(
        "solvertime",
        ["t_planning"],
        {"interval": pp._plannerparams['interval']}
    )
    pathLengthMetric = PathLengthMetric(
        "pathLength",
        fkNames,
        {}
    )
    pp.addMetric(clearanceMetric)
    pp.addMetric(timeToReachGoalMetric)
    pp.addMetric(solverTimesMetric)
    pp.addMetric(pathLengthMetric)
    pp.addMetric(selfClearanceMetric)
    pp.evaluate()
    pp.evaluateSuccess()
    pprint.pprint(pp.getEval())
    pp.writeEval2ResultFolder()

def postProcess(folderName):
    if "pointMass" in folderName:
        postProcessPointMass(folderName)
    elif "planarArm" in folderName:
        postProcessPlanarArm(folderName)

if __name__ == "__main__":
    postProcess(sys.argv[1])
