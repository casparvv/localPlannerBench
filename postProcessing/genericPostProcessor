#! /usr/bin/python3

import subprocess
import argparse
import numpy as np
import csv
import sys
import os
import yaml
import pprint

from fabricsExperiments.generic.experiment import Experiment
from fabricsExperiments.generic.fabricPlanner import FabricPlanner
from fabricsExperiments.generic.mpcPlanner import MPCPlanner

from metrics import (
    DistanceToPointMetric,
    MinimumDistanceToPointMetric,
    TimeToReachGoalMetric,
    ClearanceMetric,
    SelfClearanceMetric,
    SolverTimesMetric,
    PathLengthMetric,
    SuccessMetric,
    IntegratedErrorMetric
)


def csvToRawData(fileName):
    with open(fileName) as csvfile:
        reader = csv.reader(csvfile, delimiter=",")
        return list(reader)


def listStr2FloatArray(strList):
    return np.array([float(entry) for entry in strList])


class PostProcessor(object):
    def __init__(self):
        self.initializeArgumentParser()
        self._metrices = []
        self.parseArguments()

    def initializeArgumentParser(self):
        self._parser = argparse.ArgumentParser(
            "Run post processing for motion planning experiment"
        )
        self._parser.add_argument(
            "--expFolder",
            "-exp",
            type=str,
            help="Experiment result folder",
            required=True,
        )
        self._parser.add_argument("--series", dest="series", action="store_true")
        self._parser.set_defaults(series=False)
        self._parser.add_argument("--plot", dest="plot", action="store_true")
        self._parser.set_defaults(plot=False)
        self._parser.add_argument("--verbose", dest="verbose", action="store_true")
        self._parser.set_defaults(verbose=False)

    def importData(self):
        self.convertDataPoints(csvToRawData(self._expFolder + "/res.csv"))
        self._experiment = Experiment(self._expFolder + "/exp.yaml")
        if "/fabric_" in self._expFolder or '/dynamicFabric_' in self._expFolder:
            self._planner = FabricPlanner(
                self._experiment, self._expFolder + "/planner.yaml"
            )
        elif "/mpc_" in self._expFolder:
            self._planner = MPCPlanner(
                self._experiment, self._expFolder + "/planner.yaml"
            )
        if self._experiment.robotType() == "pointMass":
            self.defineMetricesPointMass()
        elif self._experiment.robotType() == "planarArm":
            self.defineMetricesPlanarArm()
        elif self._experiment.robotType() == "panda":
            self.defineMetricesPanda()

    def parseArguments(self):
        args = self._parser.parse_args()
        self._expFolder = os.getcwd() + "/" + args.expFolder
        self._series = args.series
        self._plot = args.plot
        self._verbose = args.verbose

    def processHeader(self, header):
        headerDict = {}
        for i, entry in enumerate(header):
            headerDict[entry] = i
        return headerDict

    def convertDataPoints(self, rawdata):
        nbPoints = len(rawdata) - 1
        self._data = {}
        headerDict = self.processHeader(rawdata[0])
        for name in headerDict.keys():
            self._data[name] = np.array(
                [float(rawdata[i][headerDict[name]]) for i in range(1, nbPoints)]
            )

    def evaluateMetric(self, metric):
        return metric.computeMetric(self._data)

    def addMetric(self, metric):
        self._metrices.append(metric)

    def defineMetricesPointMass(self):
        timeToReachGoalMetric = TimeToReachGoalMetric(
            "time2Goal",
            ["q0", "q1", "goal_0_0", "goal_1_0", "t"],
            {"m": 2, "des_distance": 0.1},
        )
        integratedErrorMetric = IntegratedErrorMetric(
            "integratedError",
            ["q0", "q1", "goal_0_0", "goal_1_0", "t"],
            {"m": 2, "des_distance": 0.1},
        )
        clearanceMetric = ClearanceMetric(
            "clearance",
            ["q0", "q1"],
            {
                "obstacles": self._experiment.obstacles(),
                "n": 1,
                "m": 2,
                "r_body": self._experiment.rBody(),
            },
        )
        solverTimesMetric = SolverTimesMetric(
            "solvertime", ["t_planning"], {"interval": self._planner.interval()}
        )
        pathLengthMetric = PathLengthMetric("pathLength", ["q0", "q1"], {})
        self._metrices = []
        self.addMetric(clearanceMetric)
        self.addMetric(timeToReachGoalMetric)
        self.addMetric(solverTimesMetric)
        self.addMetric(pathLengthMetric)
        self.addMetric(integratedErrorMetric)

    def defineMetricesPlanarArm(self):
        n = self._experiment.n()
        m = 2
        fksNames = []
        for i in range(1, n + 1):
            fksNames.append("fk" + str(i) + "_x")
            fksNames.append("fk" + str(i) + "_y")
        fkNames = ["fk" + str(n) + "_x", "fk" + str(n) + "_y"]
        timeToReachGoalMetric = TimeToReachGoalMetric(
            "time2Goal",
            fkNames + ['goal_0_0', 'goal_1_0', "t"],
            {"m": 2, "des_distance": 0.1},
        )
        clearanceMetric = ClearanceMetric(
            "clearance",
            fksNames,
            {
                "obstacles": self._experiment.obstacles(),
                "m": m,
                "n": n,
                "r_body": self._experiment.rBody(),
            },
        )
        selfClearanceMetric = SelfClearanceMetric(
            "selfClearance",
            ["fk0_x", "fk0_y"] + fksNames,
            {
                "m": m,
                "n": n,
                "r_body": self._experiment.rBody(),
                "pairs": self._experiment.selfCollisionPairs()}
        )
        solverTimesMetric = SolverTimesMetric(
            "solvertime", ["t_planning"], {"interval": self._planner.interval()}
        )
        pathLengthMetric = PathLengthMetric("pathLength", fkNames, {})
        self._metrices = []
        self.addMetric(clearanceMetric)
        self.addMetric(timeToReachGoalMetric)
        self.addMetric(solverTimesMetric)
        self.addMetric(pathLengthMetric)
        self.addMetric(selfClearanceMetric)

    def defineMetricesPanda(self):
        n = self._experiment.n()
        m = 3
        fksNames = []
        for i in range(1, n + 1):
            fksNames.append("fk" + str(i) + "_x")
            fksNames.append("fk" + str(i) + "_y")
            fksNames.append("fk" + str(i) + "_z")
        fkNames = ["fk" + str(n) + "_x", "fk" + str(n) + "_y", "fk" + str(n) + "_z"]
        timeToReachGoalMetric = TimeToReachGoalMetric(
            "time2Goal",
            fkNames + ['goal_0_0', 'goal_1_0', 'goal_2_0', "t"],
            {"m": 3, "des_distance": 0.1},
        )
        clearanceMetric = ClearanceMetric(
            "clearance",
            fksNames,
            {
                "obstacles": self._experiment.obstacles(),
                "m": m,
                "n": n,
                "r_body": self._experiment.rBody(),
            },
        )
        selfClearanceMetric = SelfClearanceMetric(
            "selfClearance",
            ["fk0_x", "fk0_y", "fk0_z"] + fksNames,
            {
                "m": m,
                "n": n,
                "r_body": self._experiment.rBody(),
                "pairs": self._experiment.selfCollisionPairs(),
            },
        )
        solverTimesMetric = SolverTimesMetric(
            "solvertime", ["t_planning"], {"interval": self._planner.interval()}
        )
        pathLengthMetric = PathLengthMetric("pathLength", fkNames, {})
        self._metrices = []
        self.addMetric(clearanceMetric)
        self.addMetric(timeToReachGoalMetric)
        self.addMetric(solverTimesMetric)
        self.addMetric(pathLengthMetric)
        self.addMetric(selfClearanceMetric)

    def evaluate(self):
        if self._series:
            self.seriesEvaluate(['solvertime', 'integratedError', 'clearance'])
        else:
            self.singleEvaluate()

    def seriesEvaluate(self, kpiNames):
        seriesFolder = self._expFolder
        listExpFolders = os.listdir(self._expFolder)
        totalExps = 0
        fullPaths = [self._expFolder + "/" + exp for exp in listExpFolders]
        kpis = {}
        for fullPath in fullPaths:
            if not os.path.isdir(fullPath):
                continue
            totalExps += 1
            self._expFolder = fullPath
            self.singleEvaluate()
            timeStamp = self.getTimeStamp()
            kpi = self.getKpis(kpiNames)
            if not self._planner.plannerType() in kpis.keys():
                kpis[self._planner.plannerType()] = {}
            kpis[self._planner.plannerType()][timeStamp] = kpi
        resultArray, feasibility, success = self.getSeriesComparison(kpis, kpiNames)
        self._expFolder = seriesFolder
        self.writeSeriesResult(kpis, resultArray, feasibility, success)
        if self._plot:
            planners = list(kpis.keys())
            self.plotSeriesResult(planners[0], planners[1], kpiNames)

    def getSeriesComparison(self, kpis, kpiNames):
        planner1Matrix = []
        planner2Matrix = []
        planner1Counter = {0: 0, -1: 0, -2: 0}
        planner2Counter = {0: 0, -1: 0, -2: 0}
        planner1Kpis = list(kpis.values())[0]
        planner2Kpis = list(kpis.values())[1]
        feasibility = []
        for timeStamp in planner1Kpis.keys():
            planner1Success =planner1Kpis[timeStamp][0]['short']
            planner2Success = planner2Kpis[timeStamp][0]['short']
            feasibility.append(
                [timeStamp, planner1Kpis[timeStamp][0]['flag'], planner2Kpis[timeStamp][0]['flag']]
            )
            planner1Counter[planner1Kpis[timeStamp][0]['flag']] += 1
            planner2Counter[planner2Kpis[timeStamp][0]['flag']] += 1
            if planner1Success and planner2Success:
                planner1Matrix.append(planner1Kpis[timeStamp][1:])
                planner2Matrix.append(planner2Kpis[timeStamp][1:])
        results = np.array(planner1Matrix) / np.array(planner2Matrix)
        resultDict = {}
        for i, kpiName in enumerate(kpiNames):
            resultDict[kpiName] = list(results[:, i])
        success = [list(planner1Counter.values()), list(planner2Counter.values())]
        return resultDict , feasibility, success

    def getTimeStamp(self):
        return self._expFolder[-15:]

    def singleEvaluate(self):
        print("Evaluating experiment %s" % self._expFolder)
        self.importData()
        self._evaluations = {}
        for metric in self._metrices:
            res = metric.computeMetric(self._data)
            self._evaluations[metric._name] = res
        if self._verbose:
            pprint.pprint(self._evaluations)
        if self._plot:
            self.plot()
        self.evaluateSuccess()
        self.writeEval2ResultFolder()

    def getEval(self):
        return self._evaluations

    def getKpis(self, kpiNames):
        success = self._evaluations["success"]
        return [success] + [self._evaluations[kpiName]['short'] for kpiName in kpiNames]

    def evaluateSuccess(self):
        if "selfClearance" in self._evaluations.keys():
            minClearance = min(
                self._evaluations["clearance"]["short"],
                self._evaluations["selfClearance"]["short"],
            )
        else:
            minClearance = self._evaluations["clearance"]["short"]
        reachingFlag = self._evaluations["time2Goal"]['flag']
        successMetric = SuccessMetric(
            "success", [], {"minClearance": minClearance, "reachingFlag": reachingFlag},
        )
        self._evaluations["success"] = self.evaluateMetric(successMetric)

    def writeSeriesResult(self, seriesRes, resultDict, feasibility, success):
        postProcessFile = self._expFolder + "/postProcess.yaml"
        seriesCsvFile = self._expFolder + "/results.csv"
        feasibilityFile = self._expFolder + "/feasibility.csv"
        successFile = self._expFolder + "/success.csv"
        with open(postProcessFile, "w") as file:
            yaml.dump(seriesRes, file)
        with open(seriesCsvFile, "w") as file:
            csv_writer = csv.writer(file, delimiter=",")
            csv_writer.writerow(list(resultDict))
            resultList = list(resultDict.values())
            for i in range(len(resultList[0])):
                row = [resultList[j][i] for j in range(len(resultList))]
                csv_writer.writerow(row)
        with open(feasibilityFile, "w") as file:
            csv_writer = csv.writer(file, delimiter=",")
            for i in range(len(feasibility)):
                csv_writer.writerow(feasibility[i])
        with open(successFile, "w") as file:
            csv_writer = csv.writer(file, delimiter=",")
            for i in range(len(success)):
                csv_writer.writerow(success[i])

    def writeEval2ResultFolder(self):
        postProcessFile = self._expFolder + "/postProcess.yaml"
        with open(postProcessFile, "w") as file:
            yaml.dump(self._evaluations, file)

    def plot(self):
        curPath = os.path.dirname(os.path.abspath(__file__)) + "/"
        if self._experiment.robotType() == "planarArm":
            createPlotFolder = curPath + "plottingPlanarArm"
            subprocess.Popen(
                ["./createPlot", self._expFolder, str(self._experiment.n())],
                cwd=createPlotFolder,
                stdout=subprocess.PIPE,
            )
        elif self._experiment.robotType() == "pointMass":
            createPlotFolder = curPath + "plottingPointMass/"
            subprocess.Popen(
                ["./createPlot", self._expFolder],
                cwd=createPlotFolder,
                stdout=subprocess.PIPE,
            )
        elif self._experiment.robotType() == "panda":
            createPlotFolder = curPath + "plottingPanda/"
            subprocess.Popen(
                ["./createPlot", self._expFolder],
                cwd=createPlotFolder,
                stdout=subprocess.PIPE,
            )

    def plotSeriesResult(self, planner1, planner2, kpiNames):
        curPath = os.path.dirname(os.path.abspath(__file__)) + "/"
        subprocess.Popen(
            ["./createSeriesPlot", self._expFolder, planner1, planner2] + kpiNames, cwd=curPath, stdout=subprocess.PIPE
        )
        subprocess.Popen(
            ["./createSuccessPlot", self._expFolder, planner1, planner2],
            cwd=curPath,
            stdout=subprocess.PIPE,
        )

    def open(self):
        subprocess.Popen(["xdg-open", self._expFolder], stdout=subprocess.PIPE)


if __name__ == "__main__":
    pp = PostProcessor()
    pp.evaluate()
    pp.open()
